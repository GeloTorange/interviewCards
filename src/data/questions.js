export const QUESTIONS = [
  { id: '1', topic: 'JavaScript', question: 'Что такое лексическое окружение и замыкание?', answer: 'Лексическое окружение хранит связи между идентификаторами и значениями в момент объявления. Замыкание — это функция вместе с её лексическим окружением, благодаря чему функция имеет доступ к переменным внешней области, даже если та уже завершила выполнение.' },
  { id: '2', topic: 'JavaScript', question: 'Чем отличается область видимости функции от блочной области видимости?', answer: 'var ограничен областью функции и подвержен hoisting, let/const имеют блочную область видимости и доступны только внутри блока. Это помогает избегать утечек и коллизий имён переменных.' },
  { id: '3', topic: 'JavaScript', question: 'Что поднимается при hoisting и как ведут себя let/const?', answer: 'Поднимаются объявления функций и переменных, но инициализация не поднимается. У let/const существует временная мёртвая зона до инициализации, обращение в этот период приводит к ошибке.' },
  { id: '4', topic: 'JavaScript', question: 'Как определяется значение this?', answer: 'Значение this зависит от способа вызова: как метод объекта — объект, как конструктор через new — новый экземпляр, обычный вызов в strict — undefined. Стрелочные функции не имеют собственного this и берут его из внешнего контекста.' },
  { id: '5', topic: 'JavaScript', question: 'Для чего нужны call, apply и bind?', answer: 'Они позволяют явно задать значение this. call принимает аргументы по одному, apply — массивом, bind возвращает новую функцию с привязанным контекстом и частично применёнными аргументами.' },
  { id: '6', topic: 'JavaScript', question: 'Чем отличаются == и === и когда уместен Object.is?', answer: '=== сравнивает без приведения типов, тогда как == выполняет неявное приведение и может давать неожиданные результаты. Object.is корректно сравнивает -0 и NaN и полезен для точных сравнений.' },
  { id: '7', topic: 'JavaScript', question: 'Что такое прототипное наследование?', answer: 'Каждый объект содержит ссылку [[Prototype]] на другой объект. При доступе к свойству движок ищет его в объекте, затем поднимается по цепочке прототипов. Классы — синтаксический сахар над этой моделью.' },
  { id: '8', topic: 'JavaScript', question: 'Для чего нужны Map/Set и WeakMap/WeakSet?', answer: 'Map/Set обеспечивают предсказуемую итерацию и ключи любого типа/уникальные значения. WeakMap/WeakSet хранят слабые ссылки, позволяя GC удалять элементы без утечек, но они не итерируемы.' },
  { id: '9', topic: 'JavaScript', question: 'Как работает event loop: микрозадачи и макрозадачи?', answer: 'Микрозадачи (обработчики промисов) выполняются перед переходом к следующей макрозадаче (таймеры, IO). Поэтому Promise.then выполнится раньше setTimeout(..., 0).' },
  { id: '10', topic: 'JavaScript', question: 'Как безопасно копировать объекты без мутаций?', answer: 'Для неглубоких структур используют spread/Object.assign, для глубоких — structuredClone или специализированные утилиты. Это предотвращает неожиданные побочные эффекты от общих ссылок.' },
  { id: '11', topic: 'JavaScript', question: 'Почему 0.1 + 0.2 !== 0.3 и как сравнивать числа с плавающей запятой?', answer: 'Из-за двоичной арифметики получаем неточное представление 0.30000000000000004. Сравнивают с допуском: Math.abs(a - b) < Number.EPSILON.' },
  { id: '12', topic: 'JavaScript', question: 'Что такое генераторы и где применяются?', answer: 'Генераторы — функции, которые можно приостанавливать/возобновлять через yield/next. Подходят для ленивых последовательностей, итераторов и управляемой кооперативной асинхронности.' },
  { id: '13', topic: 'JavaScript', question: 'Зачем нужен optional chaining и nullish coalescing?', answer: 'a?.b безопасно обращается к вложенному свойству, а x ?? y возвращает y только если x — null/undefined. Это сокращает количество защитных проверок и делает код выразительнее.' },
  { id: '14', topic: 'JavaScript', question: 'Как избежать утечек памяти в JS?', answer: 'Освобождать ссылки на ненужные объекты, отписываться от событий, не хранить крупные структуры в замыканиях без нужды. Для временных ассоциаций использовать WeakMap/WeakSet.' },
  { id: '15', topic: 'JavaScript', question: 'Чем отличаются синхронные и асинхронные итераторы?', answer: 'Синхронный итератор возвращает значения сразу, асинхронный — промисы и используется с for await...of. Это удобно для потоков данных и ленивой загрузки.' },
  { id: '16', topic: 'JavaScript', question: 'Что такое Proxy и Reflect?', answer: 'Proxy перехватывает операции с объектами (get, set, has), позволяя реализовать реактивность/валидацию. Reflect предоставляет безопасные аналоги базовых операций и упрощает ловушки Proxy.' },
  { id: '17', topic: 'JavaScript', question: 'В чём разница между shallow и deep equality для объектов?', answer: 'Поверхностное сравнение проверяет только верхний уровень свойств, глубокое — всю структуру. В UI это влияет на shouldComponentUpdate/мемоизацию: важно выбирать корректную стратегию сравнений.' },
  { id: '18', topic: 'JavaScript', question: 'Когда использовать reduce вместо map+filter?', answer: 'reduce уместен, когда нужен один проход для свёртки в значение/структуру (группировки, индексация). Если выражение становится нечитаемым — лучше разделить на map/filter для ясности.' },
  { id: '19', topic: 'JavaScript', question: 'Зачем нужны символы (Symbol) и BigInt?', answer: 'Symbol создаёт уникальные ключи свойств, исключая конфликты имён. BigInt позволяет работать с целыми числами произвольной длины, избегая переполнений и потери точности.' },
  { id: '20', topic: 'JavaScript', question: 'Как работает try/catch с async/await и Promise?', answer: 'Внутри async функции try/catch перехватывает ошибки await. Для Promise-цепочек используют .catch, а в массивах промисов — Promise.allSettled для управляемой обработки результатов.' },
  { id: '21', topic: 'Browser', question: 'DOM vs CSSOM и CRP — как ускорить первую отрисовку?', answer: 'Браузер строит DOM и CSSOM, затем рассчитывает layout и рисует. Сокращайте блокирующий CSS, инлайните критические стили, используйте defer/async для скриптов и preconnect/preload для важных ресурсов.' },
  { id: '22', topic: 'Browser', question: 'Reflow и repaint — что дороже и как их уменьшить?', answer: 'Reflow дороже, так как требует перерасчёта геометрии и релейаута. Минимизируйте доступ к layout-триггерам, группируйте изменения, используйте transform/opacity и requestAnimationFrame.' },
  { id: '23', topic: 'Browser', question: 'Разница между async и defer для script?', answer: 'Оба загружают параллельно. async выполняется по готовности (порядок не гарантирован), defer — после парсинга HTML в порядке появления, и не блокирует DOM.' },
  { id: '24', topic: 'Browser', question: 'Delegation: зачем вешать обработчик на контейнер?', answer: 'Это снижает число слушателей, работает с динамическими узлами и экономит память. Событие ловят на всплытии и различают цели по селекторам/атрибутам.' },
  { id: '25', topic: 'Browser', question: 'localStorage, sessionStorage и cookie — когда что?', answer: 'Cookie — для данных, необходимых на сервере (сессии, аутентификация). localStorage хранит долгосрочные настройки клиента, sessionStorage — состояние текущей вкладки.' },
  { id: '26', topic: 'Browser', question: 'AbortController для отмены fetch в UI-паттернах', answer: 'При смене страницы/фильтров отменяйте «устаревшие» запросы, чтобы избежать гонок и лишних перерисовок. Это повышает отзывчивость и экономит ресурсы.' },
  { id: '27', topic: 'Browser', question: 'IntersectionObserver — практические кейсы', answer: 'Ленивая загрузка изображений, бесконечная прокрутка, аналитика видимости блоков. Нативное API избавляет от ручного вычисления позиций и скролл-листенеров.' },
  { id: '28', topic: 'Browser', question: 'Service Worker vs Web Worker — различия и кейсы', answer: 'SW перехватывает сеть, обеспечивает офлайн/кэш/пуш и требует HTTPS. Web Worker — фоновая параллельная среда без доступа к DOM для тяжёлых вычислений.' },
  { id: '29', topic: 'Browser', question: 'History API и SPA-роутинг', answer: 'pushState/replaceState позволяют менять URL без перезагрузки, интегрируясь с клиентским роутингом. Важно корректно обрабатывать назад/вперёд и восстановление состояния.' },
  { id: '30', topic: 'Browser', question: 'Браузерное кеширование: Cache-Control, ETag, immutable', answer: 'Долгоживущие ресурсы версионируют через хэши и помечают immutable. Динамику кэшируют условно через ETag/Last-Modified, соблюдая баланс между свежестью и скоростью.' },
  { id: '31', topic: 'TypeScript', question: 'type vs interface — когда что выбирать?', answer: 'interface поддерживает declaration merging и удобен для публичных API, type — для объединений/пересечений/кортежей. Часто это вопрос стиля и задач типовой трансформации.' },
  { id: '32', topic: 'TypeScript', question: 'Generics в компонентах и функциях — ключевые паттерны', answer: 'Дженерики повышают переиспользуемость и безопасность типов. Ими типизируют пропсы, хелперы и фабрики, сохраняя точность инференса без any.' },
  { id: '33', topic: 'TypeScript', question: 'Type guards и narrowing — как убедить компилятор?', answer: 'Проверяйте типы через typeof/instanceof/кастомные предикаты и сужайте объединения. Это позволяет безопасно вызывать методы конкретного типа без приведения.' },
  { id: '34', topic: 'TypeScript', question: 'any, unknown и never — различия и практики', answer: 'any отключает проверки и опасен, unknown требует явного сужения и безопаснее, never обозначает отсутствие значения. Включайте strict-режим и избегайте неявного any.' },
  { id: '35', topic: 'TypeScript', question: 'enum vs const enum — плюсы и ограничения', answer: 'enum создаёт рантайм-объект и двунаправленное сопоставление, const enum инлайнится числами при компиляции. Последний нельзя использовать, если нужен объект перечисления в рантайме.' },
  { id: '36', topic: 'TypeScript', question: 'Utility Types: Partial, Required, Pick, Omit, Record', answer: 'Они модифицируют существующие типы без дублирования и повышают выразительность. В сочетании с условными типами позволяют строить мощные типовые утилиты.' },
  { id: '37', topic: 'TypeScript', question: 'Conditional Types и распределительные условные типы', answer: 'T extends U ? X : Y позволяет выражать зависимости на уровне типов. Распределительные типы применяются к объединениям и раскрывают мощные паттерны типизации.' },
  { id: '38', topic: 'TypeScript', question: 'Типизация React-компонентов с дженериками', answer: 'Задавайте <T,>(props: Props<T>) и учитывайте default-значения и Partial при опциональных пропсах. Следите за стабильностью проп-типов для корректной мемоизации.' },
  { id: '39', topic: 'TypeScript', question: 'declare module и ambient declarations', answer: 'Используйте для описания внешних модулей или глобалей, если нет d.ts. Это обеспечивает автодополнение и безопасность при работе со сторонними пакетами.' },
  { id: '40', topic: 'TypeScript', question: 'Строгий режим tsconfig — какие флаги важны?', answer: 'strict, strictNullChecks, noImplicitAny, noUncheckedIndexedAccess и strictBindCallApply. Они выявляют ошибки на этапе компиляции и улучшают DX.' },
  { id: '41', topic: 'TypeScript', question: 'Типизация API-ответов и безопасный парсинг', answer: 'Определяйте точные интерфейсы, используйте zod/io-ts для runtime-валидации. Это защищает от несовпадений контрактов и снижает риск рантайм-ошибок.' },
  { id: '42', topic: 'React', question: 'Props vs State — разделение ответственности', answer: 'Props приходят извне и неизменяемы, state — внутреннее состояние, меняется через setState/useState. Чёткое разделение делает поток данных предсказуемым.' },
  { id: '43', topic: 'React', question: 'Правила хуков и почему они важны', answer: 'Хуки вызывают только на верхнем уровне и только в компонентах/кастомных хуках. Это гарантирует одинаковый порядок вызовов между рендерами.' },
  { id: '44', topic: 'React', question: 'useEffect — зависимости, очистка и гонки', answer: 'Всегда указывайте зависимости и возвращайте функцию очистки для подписок/таймеров. Для запросов используйте AbortController, чтобы избегать гонок при быстрых сменах экрана.' },
  { id: '45', topic: 'React', question: 'React.memo vs useMemo vs useCallback', answer: 'React.memo мемоизирует вывод компонента, useMemo — вычисленное значение, useCallback — ссылку на функцию. Применяйте осознанно, измеряйте профайлером, избегайте микроменеджмента.' },
  { id: '46', topic: 'React', question: 'Ключи в списках и почему индекс — плохая идея', answer: 'Ключи помогают диффу правильно сопоставлять элементы. Индекс ломает соответствие при вставках/удалениях и может привести к утечкам состояния.' },
  { id: '47', topic: 'React', question: 'Context vs Redux/Zustand — критерии выбора', answer: 'Context хорош для редких обновлений и сквозных данных (тема, локаль). Для сложных глобальных состояний, кешей и инструментов — Redux Toolkit/Zustand/React Query.' },
  { id: '48', topic: 'React', question: 'Code splitting: React.lazy + Suspense', answer: 'Лениво грузите тяжёлые компоненты и показывайте fallback. Это уменьшает стартовый бандл и улучшает LCP, но требует продуманной загрузки критических путей.' },
  { id: '49', topic: 'React', question: 'Error Boundaries — ограничения и применение', answer: 'Ловят ошибки рендера и lifecycle дочерних компонентов, но не асинхронные/событийные. Используйте для изоляции зон и дружелюбных резервных UI.' },
  { id: '50', topic: 'React', question: 'Оптимизация таблиц и списков', answer: 'Виртуализируйте (react-window), мемоизируйте ячейки, используйте стабильные ключи и селективные подписки на стор. Избегайте тяжёлых ререндеров по глобальным изменениям.' },
  { id: '51', topic: 'React', question: 'Контролируемые vs неконтролируемые формы', answer: 'Контролируемые дают полный контроль и валидацию, но дороже по перерисовкам. Неконтролируемые через ref проще и быстрее для простых форм.' },
  { id: '52', topic: 'React', question: 'Стабильность ссылок и зависимости эффектов', answer: 'Стабилизируйте колбэки через useCallback и значения через useMemo, чтобы не триггерить эффекты и мемо-компоненты зря. Следите за тем, что попадает в deps.' },
  { id: '53', topic: 'React', question: 'Concurrent возможности и отзывчивость UI', answer: 'React может прерывать дорогостоящие рендеры и отдавать приоритет интерактивности. Это улучшает UX при вводе и навигации в тяжёлых интерфейсах.' },
  { id: '54', topic: 'React', question: 'Антипаттерны: derived state и глубокие пропсы', answer: 'Не дублируйте данные из пропсов в state без причины, используйте селекторы и композицию. Глубокие пропсы сигналят о необходимости пересмотра архитектуры.' },
  { id: '55', topic: 'React', question: 'Композиция vs наследование в компонентах', answer: 'React поощряет композицию: прокидывайте детей, слоты и рендер-пропсы. Наследование редко уместно и усложняет повторное использование.' },
  { id: '56', topic: 'React', question: 'Suspense для данных — зачем и как?', answer: 'Позволяет показывать fallback до готовности данных и координировать параллельные запросы. Требует интеграции с React 18 подходами и поддерживающими библиотеками.' },
  { id: '57', topic: 'React', question: 'Паттерны контейнер/презентация и собственные хуки', answer: 'Выносите бизнес-логику в контейнеры/хуки, оставляя компоненты чистыми. Это повышает тестируемость, повторное использование и упрощает дерево.' },
  { id: '58', topic: 'React', question: 'Оптимизация рендеринга форм', answer: 'Делите форму на секции, используйте контроллеры полей и мемоизацию. Селективные перерисовки и Debounce/Throttle повышают отзывчивость.' },
  { id: '59', topic: 'React', question: 'Серверный рендер и гидратация — плюсы/минусы', answer: 'SSR ускоряет первый meaningful paint и улучшает SEO, но усложняет инфраструктуру и требует синхронизации стейта на клиенте. Гидратация дороже, чем чистый CSR.' },
  { id: '60', topic: 'React', question: 'Взаимодействие с Web Workers из React', answer: 'Тяжёлые вычисления переносите в воркеры, общайтесь через postMessage и подписки в эффектах. Это снижает блокировки главного потока и улучшает INP.' },
  { id: '61', topic: 'React', question: 'Управление фокусом и порталы', answer: 'Порталы упрощают модальные окна/меню поверх остального UI, но требуют управления фокусом и aria-атрибутами. Это важно для доступности и UX.' },
  { id: '62', topic: 'HTML/CSS', question: 'Семантика HTML и роль для a11y/SEO', answer: 'Семантические теги (header, nav, main, section, article, footer) передают смысл и структуру, улучшают навигацию скринридеров и индексируемость. Это базис доступного и понятного интерфейса.' },
  { id: '63', topic: 'HTML/CSS', question: 'Box model и box-sizing', answer: 'Box model включает content, padding, border и margin. Схема border-box упрощает расчёты адаптивных размеров и предотвращает переполнения.' },
  { id: '64', topic: 'HTML/CSS', question: 'Flexbox vs Grid — критерии выбора', answer: 'Flex — одномерная компоновка и выравнивание вдоль одной оси, Grid — двумерные сетки и сложные макеты. Часто комбинируют: Grid для макета, Flex для локальных блоков.' },
  { id: '65', topic: 'HTML/CSS', question: 'Позиционирование: relative/absolute/fixed/sticky', answer: 'Absolute позиционируется от ближайшего позиционированного предка, fixed — от вьюпорта, sticky «прилипает» при прокрутке. Выбор влияет на поток и stacking context.' },
  { id: '66', topic: 'HTML/CSS', question: 'Псевдоэлементы и :focus-visible', answer: '::before/::after добавляют декоративный контент, а :focus-visible стилизует видимый фокус для клавиатуры. Это помогает не ломать доступность и держать визуальную консистентность.' },
  { id: '67', topic: 'HTML/CSS', question: 'Единицы px, rem, em, vw/vh', answer: 'rem масштабируется от корня и удобен для типографики, em — от родителя, vw/vh — от размеров окна. Смешивайте для адаптивности и контроля над масштабированием.' },
  { id: '68', topic: 'HTML/CSS', question: 'FOUC и способы избежать мигания', answer: 'Инлайните критический CSS, откладывайте неважные стили, используйте font-display: swap. Скрипты помечайте defer/async, минимизируйте блокирующие ресурсы.' },
  { id: '69', topic: 'HTML/CSS', question: 'Архитектуры CSS: БЭМ, CSS-модули, CSS-in-JS', answer: 'Изоляция стилей снижает конфликты и повышает предсказуемость. Выбор зависит от стека и команды, но цель — масштабируемость и читаемость.' },
  { id: '70', topic: 'HTML/CSS', question: 'Адаптивные изображения: srcset/sizes и picture', answer: 'Подавайте изображения подходящего разрешения и формата (AVIF/WebP) под устройство. Это снижает трафик и улучшает LCP.' },
  { id: '71', topic: 'HTML/CSS', question: 'z-index и stacking context', answer: 'Новые контексты создают transform, opacity<1, filter и позиционирование. Понимание их помогает решать «невидимые» перекрытия и события.' },
  { id: '72', topic: 'HTML/CSS', question: 'Сложные селекторы и производительность', answer: 'Глубокие/универсальные селекторы усложняют каскад и ухудшают поддержку. Предпочитайте предсказуемые классы и близкие к компонентам области видимости.' },
  { id: '73', topic: 'HTML/CSS', question: 'Доступное скрытие элементов', answer: 'Для визуального скрытия, но доступности — utility класса visually-hidden. aria-hidden="true" полностью скрывает от ассистивных технологий, используйте осторожно.' },
  { id: '74', topic: 'Performance', question: 'Core Web Vitals: LCP, INP, CLS — как влияют на UX и SEO?', answer: 'LCP — скорость главного контента, INP — отклик интерфейса, CLS — стабильность макета. Улучшение метрик повышает конверсию и поисковое ранжирование.' },
  { id: '75', topic: 'Performance', question: 'Практики улучшения LCP для SPA', answer: 'Уменьшайте стартовый бандл, инлайните критический CSS, оптимизируйте «герой»-изображение и используйте CDN. Рассмотрите SSR/SSG для начального контента.' },
  { id: '76', topic: 'Performance', question: 'Причины высокого CLS и профилактика', answer: 'Отсутствие размеров медиа/шрифтов и поздние вставки. Резервируйте места под медиа, используйте font-display и избегайте вставок над контентом.' },
  { id: '77', topic: 'Performance', question: 'INP и длинные задачи — что делать?', answer: 'Разбивайте тяжёлые вычисления, выносите в Web Worker, мемоизируйте селекторы и снижайте количество ре-рендеров. Профилируйте в DevTools Performance.' },
  { id: '78', topic: 'Performance', question: 'Кэширование и заголовки Cache-Control/ETag', answer: 'Версионируйте статику хэшами и отдавайте immutable. Для динамики используйте условные запросы с ETag/Last-Modified, соблюдая баланс свежести и скорости.' },
  { id: '79', topic: 'Performance', question: 'Оптимизация шрифтов', answer: 'Используйте современный формат (woff2/woff2.2), subsetting и font-display: swap. Предзагружайте критичные начертания и избегайте FOIT/CLS.' },
  { id: '80', topic: 'Performance', question: 'Tree-shaking и динамический import()', answer: 'Удаляйте мёртвый код и разделяйте бандлы по маршрутам/фичам. Загружайте не критичные зависимости по требованию, измеряя влияние на TTI/LCP.' },
  { id: '81', topic: 'Performance', question: 'RUM vs синтетические тесты', answer: 'Полевые метрики отражают реальный опыт на устройствах пользователей и сетях. Комбинируйте Lighthouse/PSI с RUM-сбором для полной картины.' },
  { id: '82', topic: 'Accessibility', question: 'Почему семантика важнее ARIA?', answer: 'Нативные элементы уже имеют нужные роли, состояния и обработку клавиатуры. ARIA — дополнение, используйте, когда нативного аналога нет.' },
  { id: '83', topic: 'Accessibility', question: 'Навигация с клавиатуры и :focus-visible', answer: 'Соблюдайте естественный порядок, не убирайте outline без замены, используйте :focus-visible. Для кастомных виджетов управляйте tabindex и слушайте Enter/Space/Arrow.' },
  { id: '84', topic: 'Accessibility', question: 'aria-live и динамические статусы', answer: 'aria-live говорит скринридеру об обновлениях без смены фокуса, полезно для загрузок и валидаций. Выбирайте polite/assertive по важности.' },
  { id: '85', topic: 'Accessibility', question: 'Контраст по WCAG', answer: 'Минимум AA: 4.5:1 для обычного текста и 3:1 для крупного. Высокий контраст улучшает читаемость для всех пользователей.' },
  { id: '86', topic: 'Accessibility', question: 'Альтернативный текст изображений', answer: 'alt должен описывать смысл, а не «картинка». Для декоративных — alt="" и role="presentation". Избегайте избыточности.' },
  { id: '87', topic: 'Git', question: 'git merge vs rebase — когда что?', answer: 'merge сохраняет историю ветвления, rebase делает историю линейной, но переписывает её. Не делайте rebase публичных веток, чтобы не ломать историю команды.' },
  { id: '88', topic: 'Git', question: 'git cherry-pick — как и зачем?', answer: 'Переносит отдельный коммит в текущую ветку, полезно для хотфиксов. Создаёт новый коммит с другим хэшем, что может привести к двойным конфликтам при последующих слияниях.' },
  { id: '89', topic: 'Git', question: 'git fetch vs pull', answer: 'fetch только скачивает, pull скачивает и сливает (или ребейзит, если настроено). fetch даёт контроль над моментом и стратегией вливания.' },
  { id: '90', topic: 'Git', question: 'Conventional Commits и автогенерация релизов', answer: 'Единый формат упрощает CHANGELOG, семантическое версионирование и автоматизацию релизов. Команде проще понимать историю изменений.' },
  { id: '91', topic: 'Git', question: 'Pre-commit/pre-push хуки', answer: 'Автоматизируйте линт/тесты/типизацию перед коммитом/пушем. Это поднимает качество и предотвращает поломки в main.' },
  { id: '92', topic: 'NPM', question: 'npm ci vs npm i', answer: 'npm ci устанавливает зависимости строго по lock-файлу и очищает node_modules, идеально для CI. npm i может подтянуть минорные версии в рамках диапазона.' },
  { id: '93', topic: 'NPM', question: 'dependencies vs devDependencies vs peerDependencies', answer: 'dependencies — для рантайма, dev — для разработки/сборки, peer — ожидания от хост-приложения (например, react). Неправильная классификация ломает установки и бандлинг.' },
  { id: '94', topic: 'NPM', question: 'npm dedupe и борьба с дубликатами', answer: 'dedupe выравнивает дерево зависимостей, уменьшая размер и конфликты. Также помогают resolutions/overrides и внимательная фиксация версий.' },
  { id: '95', topic: 'NPM', question: 'Поле engines и private', answer: 'engines задаёт поддерживаемые версии Node/npm, а private: true предотвращает случайную публикацию пакета. Это повышает надёжность поставки.' },
  { id: '96', topic: 'Bundling', question: 'Webpack/Rollup/Vite — различия и выбор', answer: 'Webpack универсален и расширяем, Rollup силён для библиотек и tree-shaking, Vite быстр в dev за счёт ES-модулей и быстрой трансформации. Выбор зависит от типа проекта и требований к DX.' },
  { id: '97', topic: 'Bundling', question: 'HMR и сохранение состояния', answer: 'Горячая замена модулей ускоряет цикл разработки, избегая полной перезагрузки. Важно писать код, дружелюбный к HMR, корректно очищая ресурсы.' },
  { id: '98', topic: 'Bundling', question: 'Code splitting и preloading', answer: 'Делите код по маршрутам/фичам, грузите критические чанки заранее и ленивые — по требованию. Балансируйте prefetch/preload, чтобы не перегрузить сеть.' },
  { id: '99', topic: 'Bundling', question: 'Source maps в продакшне — риски и практики', answer: 'Загружайте карты в приватные системы (Sentry) и ограничивайте публичный доступ. Это сохраняет удобство отладки без раскрытия исходников.' },
  { id: '100', topic: 'Engineering', question: 'Пирамида тестирования и баланс покрытия', answer: 'Основание — быстрые unit-тесты, над ними интеграционные, на вершине — немного E2E для критических сценариев. Такой баланс даёт быстрый фидбек и устойчивость.' },
  { id: '101', topic: 'Engineering', question: 'CI/CD пайплайн для фронта', answer: 'При PR запускайте линт/тесты/типизацию, при merge — сборку и деплой на staging/production. Автоматизация снижает человеческий фактор и ускоряет релизы.' },
  { id: '102', topic: 'Engineering', question: 'Мониторинг фронта: ошибки и метрики', answer: 'Собирайте ошибки с контекстом (Sentry/LogRocket) и Web Vitals (RUM). Это выявляет деградации и регрессии в реальном мире.' },
  { id: '103', topic: 'Engineering', question: 'Code review: что проверять помимо логики', answer: 'Читаемость, простота, соответствие архитектуре, производительность и доступность. Комментарии должны быть доброжелательными и конкретными.' },
  { id: '104', topic: 'Engineering', question: 'Архитектура SPA и масштабирование', answer: 'Разделяйте домены, внедряйте дизайн-систему, определяйте контракты модулей и границы кэширования. Это упрощает эволюцию и команды могут работать параллельно.' },
  { id: '105', topic: 'UX', question: 'Навигация и сохранение состояния в URL', answer: 'Храните фильтры/страницу в query-параметрах, чтобы делиться ссылками и восстанавливать контекст. Это улучшает UX и облегчает поддержку.' },
  { id: '106', topic: 'UX', question: 'Проектирование форм с низким трением', answer: 'Делите на шаги, валидируйте на вводе, показывайте понятные ошибки и сохраняйте черновики. Маски и подсказки снижают количество отказов.' },
  { id: '107', topic: 'UX', question: 'Консистентность интерфейса и дизайн-система', answer: 'Единые токены, компоненты и правила повышают предсказуемость и скорость разработки. Дизайн-система уменьшает техдолг и улучшает качество.' },
  { id: '108', topic: 'UX', question: 'Анимации, которые помогают, а не мешают', answer: 'Анимируйте состояние/переходы для связи элементов, держите длительность короткой и свойства на GPU (transform/opacity). Избегайте навязчивых эффектов.' },
  { id: '109', topic: 'UX', question: 'Мобильный контекст и доступность касаний', answer: 'Крупные интерактивные цели, ясные CTA и адаптивная типографика. Оптимизируйте клавиатуры ввода и жесты, учитывайте медленные сети.' },
  { id: '110', topic: 'Architecture', question: 'Слоистая архитектура фронта', answer: 'Выделяйте слои: UI/компоненты, состояние/доменные сервисы, инфраструктура/запросы. Это облегчает тестирование, переиспользование и заменяемость.' },
  { id: '111', topic: 'Architecture', question: 'Границы модулей и контракты', answer: 'Определяйте публичные API модулей, скрывайте внутренности и избегайте «сквозных» зависимостей. Это уменьшает связанность и ускоряет сборку.' },
  { id: '112', topic: 'Architecture', question: 'Микрофронтенды: плюсы и риски', answer: 'Позволяют независимые релизы команд и разную технологию, но увеличивают сложность сборки, роутинга и общих зависимостей. Применяйте осознанно и стандартизируйте интерфейсы.' },
  { id: '113', topic: 'Architecture', question: 'Состояние приложения: локально, глобально, серверное', answer: 'Локальное — ближе к месту использования, глобальное — только для общих кусков, серверное — кешируйте и нормализуйте. Не превращайте стор в «единую свалку».' },
  { id: '114', topic: 'Architecture', question: 'Кеширование данных на клиенте', answer: 'Используйте стратегию tag-based инвалидации/нормализацию и политики stale-while-revalidate. Это снижает нагрузку на сеть и делает UI отзывчивее.' },
  { id: '115', topic: 'Architecture', question: 'Обработка ошибок как часть архитектуры', answer: 'Единые обработчики, Error Boundaries, централизованное логирование и пользовательские сообщения. Это повышает надёжность и упрощает поддержку.' },
  { id: '116', topic: 'Architecture', question: 'Фича-модули и независимость поставки', answer: 'Инкапсулируйте маршруты, стор, компоненты и стили внутри модулей. Это ускоряет онбординг и снижает конфликты при разработке.' },
  { id: '117', topic: 'Architecture', question: 'Конфигурация через окружение и фичефлаги', answer: 'Отделяйте конфигурацию от кода, используйте фичефлаги для постепенной раскатки. Это снижает риск релизов и ускоряет эксперименты.' },
  { id: '118', topic: 'Architecture', question: 'Стабильные интерфейсы компонентов', answer: 'Фиксируйте договор по пропсам, избегайте «маговских» пропсов и скрытых сайд-эффектов. Документируйте через Storybook/MDX.' },
  { id: '119', topic: 'Architecture', question: 'Антипаттерны архитектуры', answer: 'Глобальный «божественный» стор, кросс-импорты между доменами, сильная связанность UI и данных. Признак — тяжело тестировать/менять без каскада правок.' }
]
